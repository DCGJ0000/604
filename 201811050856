1.函数问题
（1）#include <stdio.h>
int fun(int a,int b)
{int c;
c=(a/10)*1000+(b/10)*100+(a%10)*10+b%10;
return c;
}
void main()
{int a,b;
printf("请输入两个两位数:");
scanf("%d%d",&a,&b);
printf("%d\n",fun(a,b));
}
（2）#include "stdio.h"
int fun(int a,int b)
{
int s1,g1,s2,g2,c;
g1=a%10;
g2=b%10;
s1=a/10;
s2=b/10;
c=s1*1000+s2*100+g1*10+g2;
return c;
}

void main()
{int a,b,c;
scanf("%d%d",&a,&b);
c=fun(a,b);
printf("%d",c);
}
（3）#include "stdio.h"
void main();
  void fun(int a, int b, long *c)     
{ 
    *c=a/10*1000+a%10*10+b/10+b%10*100;

}    
  void main()  
{   int a,b;
  long c;     
  printf("Input a, b:"); 
  scanf("%d%d", &a, &b);  
  fun(a, b, &c);     
  printf("合并结果c是: "%d\n", c);
  main();     
}
2.线性表问题
#include <iostream>
using namespace std;
struct monkey
{
    int num; 
    struct monkey *next; 
};
 
int main()
{ int m,n,i,j,king;
  Monkey *head, *p1,*p2;
  cin>>m>>n;
  if(n==1)
  {
        king=m;
    }
    else
    {
		p1=p2=new monkey;
        head = p1;
        p1->num=1;
        for(i=1; i<m; i++)  
        {
            p1=new monkey; 
            p1->num=i+1;
            p2->next=p1;
            p2=p1;        
        }
        p2->next=head;    
        p1=head;
        for(i=1; i<m; i++)  
        {
            
            for(j=1; j<n-1; j++) 
                p1=p1->next;    
            p2=p1->next; 
            p1->next=p2->next; 
            p1=p2->next; 
            delete p2; 
        }
        king=p1->num;
        delete p1;
    }
    cout<<king<<endl;
    return 0;
}
3.排序问题
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
struct Stu {
	int id,chinese,math,english,sum;
}stu[300];
bool cmp(struct Stu a, struct Stu b) 
{if(a.sum != b.sum) 
{return a.sum > b.sum;
} 
else 
{if(a.chinese != b.chinese) 
{return a.chinese > b.chinese;
} 
else {return a.id < b.id;
}
}
}
int main() 
{int n, i;
scanf("%d", &n);
for(i = 0; i < n; ++i) 
{stu[i].id = i+1;
scanf("%d %d %d", &stu[i].chinese, &stu[i].math, &stu[i].english);
stu[i].sum = stu[i].chinese + stu[i].math + stu[i].english;
}
sort(stu, stu+n, cmp);
for(i = 0; i < 5; ++i) 
{printf("%d %d\n", stu[i].id, stu[i].sum);
}
	return 0;
}
4.字符串问题
#include <iostream>
using namespace std;
int main() {
	cout << "病毒传染模型" << endl;
	int m, n, c;
	cin >> m;
	cin >> n;

	char array1[100][100];
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++)
		{
			cin >> array1[i][j];
		}
	}
cin >> c;
	int array2[2][100];
	int a = 0, b = 0,k = 1;
	while (k <= c)
	{
		for (int i = 0; i < n; i++) {
			for ( int j = 0; j < m; j++) {
				if (array1[i][j] == 'X')
				{
					array2[b][a] = i;
					array2[b + 1][a] = j;
					a++;
				}
			}
		}
		for ( i = 0; i < a; i++) {
			if (array2[b][i] == 0) {

				if (array2[b + 1][i] == 0)
				{
					if (array1[array2[b][i] + 1][array2[b + 1][i]] != 'P')
					{
						array1[array2[b][i] + 1][array2[b + 1][i]] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] + 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] + 1] = 'X';
					}
				}

				else if (array2[b + 1][i] == m - 1) {
					if (array1[array2[b][i] + 1][array2[b + 1][i]] != 'P')
					{
						array1[array2[b][i] + 1][array2[b + 1][i]] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] - 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] - 1] = 'X';
					}
				}

				else
				{
					if (array1[array2[b][i] + 1][array2[b + 1][i]] != 'P')
					{
						array1[array2[b][i] + 1][array2[b + 1][i]] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] - 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] - 1] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] + 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] + 1] = 'X';
					}
				}
			}
			else if (array2[b][i] == n - 1)
			{
				if (array2[b + 1][i] == 0) {
					if (array1[array2[b][i] - 1][array2[b + 1][i]] != 'P')
					{
						array1[array2[b][i] - 1][array2[b + 1][i]] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] + 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] + 1] = 'X';
					}
				}

				else if (array2[b + 1][i] == m - 1) {
					if (array1[array2[b][i] - 1][array2[b + 1][i]] != 'P')
					{
						array1[array2[b][i] - 1][array2[b + 1][i]] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] - 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] - 1] = 'X';
					}
				}

				else
				{
					if (array1[array2[b][i] - 1][array2[b + 1][i]] != 'P')
					{
						array1[array2[b][i] - 1][array2[b + 1][i]] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] - 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] - 1] = 'X';
					}
					if (array1[array2[b][i]][array2[b + 1][i] + 1] != 'P')
					{
						array1[array2[b][i]][array2[b + 1][i] + 1] = 'X';
					}
				}
			}
			else if (array2[b + 1][i] == 0) {
			if (array1[array2[b][i] - 1][array2[b + 1][i]] != 'P')
			{
				array1[array2[b][i] - 1][array2[b + 1][i]] = 'X';
			}
			if (array1[array2[b][i] + 1][array2[b + 1][i]] != 'P')
			{
				array1[array2[b][i] + 1][array2[b + 1][i]] = 'X';
			}
			if (array1[array2[b][i]][array2[b + 1][i] + 1] != 'P')
			{
				array1[array2[b][i]][array2[b + 1][i] + 1] = 'X';
			}
				}
			else if (array2[b + 1][i] == m - 1) {
			if (array1[array2[b][i] - 1][array2[b + 1][i]] != 'P')
			{
				array1[array2[b][i] - 1][array2[b + 1][i]] = 'X';
			}
			if (array1[array2[b][i] + 1][array2[b + 1][i]] != 'P')
			{
				array1[array2[b][i] + 1][array2[b + 1][i]] = 'X';
			}
			if (array1[array2[b][i]][array2[b + 1][i] - 1] != 'P')
			{
				array1[array2[b][i]][array2[b + 1][i] - 1] = 'X';
			}
				}
			else {
			if (array1[array2[b][i] - 1][array2[b + 1][i]] != 'P')
			{
				array1[array2[b][i] - 1][array2[b + 1][i]] = 'X';
			}
			if (array1[array2[b][i] + 1][array2[b + 1][i]] != 'P')
			{
				array1[array2[b][i] + 1][array2[b + 1][i]] = 'X';
			}
			if (array1[array2[b][i]][array2[b + 1][i] - 1] != 'P')
			{
				array1[array2[b][i]][array2[b + 1][i] - 1] = 'X';
			}
			if (array1[array2[b][i]][array2[b + 1][i] + 1] != 'P')
			{
				array1[array2[b][i]][array2[b + 1][i] + 1] = 'X';
			}
				}
		}
		k++;
		a = 0;
	}
	for ( i = 0; i < n; i++)
	{
		for ( int j = 0; j < m; j++)
		{
			cout << array1[i][j];
		}
		cout << endl;
	}
	system("pause");
	return 0;
}
5.栈问题
#include<stdio.h>
#include<stdlib.h>
#define OK    100001
#define ERROR 100002
struct node
{
    int data;
    struct node *next;
};

typedef struct node Node;

struct stack
{
    Node *top;
    int count;
};

typedef struct stack Stack;
int InitStack(Stack *S)
{
    S->top = NULL;
    S->count = 0;

    return OK;
}
int EmptyStack(Stack *S)
{
    return (S->count == 0) ? OK : ERROR;
}
int Push(Stack *S, int e)
{
    Node *p = (Node *)malloc(sizeof(Node));
    if (NULL == p)
    {
        return ERROR;
    }
    p->data = e;
    p->next = S->top;
    S->top = p;
    S->count++;
    return OK;
}
int GetTop(Stack *S)
{
    if (NULL == S->top)
    {
        return ERROR;
    }

    return (S->top->data);
}
int Priority(char s)
{
    switch(s)
    {
        case '(':
            return 3;
        case '*':
        case '/':
            return 2;
        case '+':
        case '-':
            return 1;
        default :
            return 0;
    }
}
int Pop(Stack *S)
{
    int e;

    if (NULL == S->top)
    {
        return ERROR;
    }
    Node *p = S->top;
    e = p->data;
    S->top = p->next;
    free(p);
    S->count--;
    return e;
}
int main()
{
    char str[100] = {0};
    int i = 0, tmp = 0, j;
    Stack num, opt;
    if (InitStack(&num) != OK || InitStack(&opt) != OK)
    {
        printf("Init Failure!\n");
        exit(1);
    }
    printf("Please input operator :\n");
    scanf("%s",&str);

    while (str[i] != '\0' || EmptyStack(&opt) != OK)
    {
        if (str[i] >= '0' && str[i] <= '9')
        {
            tmp = tmp * 10 + str[i] - '0';
            i++;

            if (str[i] < '0' || str[i] >'9')
            {
                Push(&num, tmp);
                tmp = 0;
            }
        }
        else
        {
            if (EmptyStack(&opt) == OK || (GetTop(&opt) == '(' && str[i] != ')') || 
                Priority(str[i]) > Priority(GetTop(&opt)))
            {
                Push(&opt, str[i]);
                i++;
                continue;
            }
            if (GetTop(&opt) == '(' && str[i] == ')')
            {
                Pop(&opt);
                i++;
                continue;
            }
            if ((str[i] == '\0' && EmptyStack(&opt) != OK) || str[i] == ')' && GetTop(&opt) != '(' ||
                Priority(str[i]) <= Priority(GetTop(&opt)))
            {
                switch(Pop(&opt))
                {
                    case '+':
                        Push(&num, Pop(&num) + Pop(&num));
                        break;
                    case '-':
                        j = Pop(&num);
                        Push(&num, Pop(&num) - j);
                        break;
                    case '*':
                        Push(&num, Pop(&num) * Pop(&num));
                        break;
                    case '/':
                        j = Pop(&num);
                        Push(&num, Pop(&num) / j);
                        break;
                }
                continue;
            }
        }
    }
    printf("%d\n",Pop(&num));
    return 0;
}
6.面向对象问题
#include<iostream> 
#include <math.h> 
using namespace std;
class 汽车
{
protected:
	int 轮胎;
	int 重量;
public:
	汽车(int wheels, int weight)
	{
		轮胎 = wheels;
		重量 = weight;
	}
	void disp()
	{
		cout << "轮胎=" << 轮胎 << ",重量=" << 重量 << endl;
	}
};
class 小车 :private 汽车
{
	int 核载人数;
public:
	小车(int wheels, int weight, int passenger) :汽车(wheels, weight)
	{
		核载人数 = passenger;
	}
	void disp()
	{
		汽车::disp();
		cout << "核载人数=" << 核载人数 << endl;
	}
};
class 卡车 :private 汽车
{
	int 核载人数;
	int 核载重量;
public:
	卡车(int wheels, int weight, int passenger, int payload) :汽车(wheels, weight)
	{
		核载人数 = passenger;
		核载重量 = payload;
	}
	void disp()
	{
		汽车::disp();
		cout << "核载人数=" << 核载人数 << "核载重量=" << 核载重量 << endl;
	}
};
void main()
{
	汽车 v(100, 99);
	v.disp();
	小车 c(50, 40, 30);
	c.disp();
	卡车 t(20, 15, 10, 5);
	t.disp();
}
