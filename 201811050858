　1.
  #include <iostream>
　　　using namespace std;
　　　int fun(int i,int j)
　　　{
　　　int c;
　　　c=(i/10)*10+(i%10)*1000+(j/10)*1+(j%10)*100;
　　　return c;}
　　　void fun1(int i,int j,int &c)
　　　{
　　　c=(i/10)*10+(i%10)*1000+(j/10)*1+(j%10)*100;}
　　　void fun2(int i,int j,int *c)
　　　{
　　　*c=(i/10)*10+(i%10)*1000+(j/10)*1+(j%10)*100;}
　　　int main()
　　　{
　　　int a,b,c1,c2;
　　　cin>>a>>b;
　　　fun(a,b);
　　　fun1(a,b,c1);
　　　fun2(a,b,&c2);
　　　cout<<"(1)结果为:"<<fun(a,b)<<endl;
　　　cout<<"(2)结果为:"<<c1<<endl;
　　　cout<<"(3)结果为:"<<c2<<endl;
　　　return 0;}
2.
　　　数组
　　　#include<iostream.h>
　　　 
　　　int choose(int num,int del)
　　　{
　　　 int i;
　　　 int a[100];
　　　 for(i=0;i<num;i++)
　　　  a[i]=1;     //猴子状态初始化，为1表示可能被选上，为0淘汰；
　　　 int sum=0,     //循环记数；
　　　  countOne=num;   //累积记数初始化，大于1表明还有大王候选人；
　　　 
　　　 while(countOne>1)
　　　 {
　　　  countOne=0;
　　　  for(i=0;i<num;i++)
　　　  {
　　　   sum+=a[i];
　　　   if(sum==del)
　　　    sum=a[i]=0;  //淘汰倒霉猴子；
　　　   countOne+=a[i];
　　　  }
　　　 }
　　　 
　　　 for(i=0;i<num;i++)
　　　  if(a[i]!=0)
　　　   return i;   //找到幸运猴子编号（从0开始的）；
　　　}
　　　 
　　　void main()
　　　{
　　　 int num,del;
　　　 cout<<"请输入猴子总数和淘汰数：";
　　　 cin>>num>>del;
　　　 cout<<"第"<<choose(num,del)+1<<"个猴子为王！"<<endl;
　　　}线性表
　　　#include <iostream>
　　　using namespace std;
　　　struct Monkey
　　　{
　　　    int num;  //猴子的编号
　　　    struct Monkey *next; //下一只猴子
　　　};
　　　 
　　　int main()
　　　{
　　　    int m,n,i,j,king;
　　　    Monkey *head, *p1,*p2;
　　　	cout<<"输入猴子个数m和报数n"<<endl;
　　　    cin>>m>>n;    //输入猴子总数及N
　　　    if(n==1) //如果N=1则大王就是最后一只猴子
　　　    {
　　　        king=m;
　　　    }
　　　    else
　　　    {
　　　        //用线性表做
　　　        p1=p2=new Monkey;
　　　        head = p1;//设置头
　　　        p1->num=1;//将p1的编号置1
　　　        for(i=1; i<m; i++)  //剩下的m-1只猴子
　　　        {
　　　            p1=new Monkey;  //p1是新增加的
　　　            p1->num=i+1;
　　　            p2->next=p1;
　　　            p2=p1;          //p2总是上一只
　　　        }
　　　        p2->next=head;      //最后一只指向第一只
　　　
　　　        p1=head;
　　　        for(i=1; i<m; i++)  //循环m-1次，淘汰m-1只猴子
　　　        {
　　　            for(j=1; j<n-1; j++)  //先找到第n-1只，下一只被淘汰
　　　                p1=p1->next;    
　　　            p2=p1->next;  //将p2设置为第n只猴子
　　　            //cout<<"第"<<i<<"轮淘汰"<<p2->num<<endl; 
　　　            p1->next=p2->next;
　　　            p1=p2->next;  //下一轮数数的新起点
　　　            delete p2;  //删除p2
　　　        }
　　　        king=p1->num;
　　　        delete p1;
　　　    }
　　　    cout<<king<<endl;
　　　    return 0;
　　　}
   3.
   　　　#include <iostream>
　　　#include <string.h>
　　　#include <algorithm>
　　　using namespace std;
　　　
　　　struct Stu
　　　{
　　　    int yu;
　　　    int shu;
　　　    int yin;
　　　    int sum;
　　　    int id;
　　　}stu[500];
　　　int cmp(Stu x,Stu y)
　　　{
　　　    if(x.sum!=y.sum)return x.sum>y.sum;
　　　    else
　　　    {
　　　        if(x.yu!=y.yu)return x.yu>y.yu;
　　　        else
　　　            return x.id<y.id;
　　　    }
　　　}
　　　int main()
　　　{
　　　    int n;
　　　    cin>>n;
　　　    int i;
　　　    for(i=0;i<n;i++)
　　　    {
　　　        cin>>stu[i].yu>>stu[i].shu>>stu[i].yin;
　　　        stu[i].sum=stu[i].yu+stu[i].shu+stu[i].yin;
　　　        stu[i].id=i+1;
　　　    }
　　　    sort(stu,stu+n,cmp);
　　　    for(i=0;i<5;i++)
　　　    {
　　　        cout<<stu[i].id<<" "<<stu[i].sum<<endl;
　　　    }
　　　    return 0;
       4.
       　　　#include <iostream> 
　　　#include <stdio.h>
　　　
　　　using namespace std;
　　　
　　　int main()
　　　{
　　　	char a[101][101];
　　　	int N,M,C;
　　　	int n,i,j;
　　　	
　　　	cout<<"输入地图长和宽"<<endl;
　　　	
　　　	cin>>N>>M;
　　　	
　　　	for(i=0;i<M;i++)
　　　	{
　　　		for(j=0;j<N;j++)
　　　		{cin>>a[i][j];}
　　　	}
　　　	cin>>C;
　　　	
　　　	i=0;j=0;n=1;
　　　	while(n<=C)
　　　	{for(i=0;i<M;i++)
　　　	{
　　　		for(j=0;j<N;j++)
　　　			{
　　　		if(a[i][j]=='X')
　　　		{
　　　			if(a[i+1][j]!='P'&&i+1<=M)
　　　		{a[i+1][j]='A';}
　　　		
　　　			if(a[i-1][j]!='P'&&i-1>=0)
　　　		{a[i-1][j]='A';}
　　　			
　　　			if(a[i][j+1]!='P'&&j+1<=N)
　　　			{a[i][j+1]='A';}
　　　			
　　　			if(a[i][j-1]!='P'&&j-1>=0)
　　　			{a[i][j-1]='A';}
　　　	}}}
　　　	n++;
　　　	for(i=0;i<M;i++)
　　　	{
　　　		for(j=0;j<N;j++)
　　　			{if(a[i][j]=='A')
　　　			a[i][j]='X';}
　　　	}}
　　　	
　　　	for(i=0;i<M;i++)
　　　	{
　　　		for(j=0;j<N;j++)
　　　		{cout<<a[i][j]<<"";}
　　　		cout<<endl;
　　　	}
    5.
    　　　#include<stdio.h>
　　　#include<stdlib.h>
　　　 
　　　#define OK 10000
　　　#define ERROR 10001
　　　
　　　struct node
　　　{
　　　int data;
　　　struct node *next;
　　　};
　　　
　　　typedef struct node Node;
　　　struct stack
　　　{
　　　Node *top;
　　　int count;
　　　};
　　　
　　　typedef struct stack Stack;
　　　int InitStack(Stack *S) //初始化
　　　{
　　　S->top = NULL;
　　　S->count = 0;
　　　return OK;
　　　}
　　　int EmptyStack(Stack *S)  //判断是否为空
　　　{
　　　return (S->count == 0) ? OK : ERROR;
　　　}
　　　
　　　int Push(Stack *S,int e) //头插法
　　　{
　　　Node *p = (Node *)malloc(sizeof(Node));//p为新栈顶    申请空间
　　　if(NULL == p)
　　　{
　　　return ERROR;
　　　}
　　　p->data = e;
　　　p->next = S->top;//s->top为原栈顶 
　　　S->top = p;
　　　S->count++; 
　　　return OK;
　　　}
　　　int GetTop(Stack *S)
　　　{
　　　if(NULL == S->top)
　　　{
　　　return ERROR;
　　　}
　　　return (S->top->data);
　　　}
　　　
　　　int Priority(char s)
　　　{
　　　switch(s)
　　　{
　　　case'(':
　　　return 3;
　　　case'*':
　　　case'/':
　　　return 2;
　　　case'+':
　　　case'-':
　　　return 1;
　　　default:
　　　return 0;}
　　　}
　　　int Pop(Stack *S)
　　　{
　　　	int e;
　　　
　　　if(NULL == S->top)
　　　{
　　　    return ERROR;
　　　}
　　　    Node *p = S->top;   
　　　   e = p->data;
　　　    S->top = p->next;
　　　    free(p);
　　　  S->count--;
　　　	return e;
　　　}
　　　int main()
　　　{
　　　Stack num, opt;//两个栈一个储存数字一个储存运算符
　　　char str[100] ={0};
　　　int i = 0,tmp = 0,j;
　　　if (InitStack(&num) !=OK || InitStack(&opt) !=OK)
　　　{
　　　printf("初始化失败\n");
　　　exit(1);  //表示退出异常
　　　}
　　　printf("请输入算式:\n");
　　　scanf("%s",str);
　　　while(str[i] !='\0' || EmptyStack(&opt) !=OK)//不为空
　　　{
　　　if (str[i] >= '0' && str[i] <='9')   //如果是数字 
　　　{
　　　tmp = tmp * 10 + str[i] - '0';  //将个位转为十位  百位
　　　i++;
　　　if (str[i] < '0' || str[i] >'9') //i++后如果不是数字 入栈后清零tmp
　　　{
　　　Push(&num,tmp);
　　　tmp = 0;
　　　}
　　　}
　　　	else
　　　	{
　　　		if ((EmptyStack(&opt) ==OK) || (GetTop(&opt)=='(' && str[i] !=')')|| //进栈不运算
　　　	(Priority(str[i])>Priority(GetTop(&opt))))//运算等级大于栈顶运算等级
　　　		{
　　　		Push(&opt,str[i]);//入栈
　　　		i++;
　　　		continue;
　　　		}
　　　
　　　	if (GetTop(&opt)=='(' && str[i] ==')')  //出栈不运算   两个括号
　　　		{
　　　	Pop(&opt); //出栈
　　　		i++;
　　　		continue;// 结束当前循环
　　　		}
　　　
　　　	if ((str[i]=='\0' && EmptyStack(&opt) !=OK) || (str[i]==')' && GetTop(&opt) !='(')||  //出栈运算
　　　			(Priority(str[i])<=Priority(GetTop(&opt))))  //注意没有i++;
　　　		{
　　　		switch(Pop(&opt))
　　　		{
　　　		case '+':
　　　	Push(&num,Pop(&num)+Pop(&num));
　　　		break;
　　　		case '-':
　　　		j = Pop(&num);
　　　		Push(&num,Pop(&num)-j);
　　　		break;
　　　    	case '*':
　　　	Push(&num,Pop(&num)*Pop(&num));
　　　		break;
　　　		case '/':
　　　		j = Pop(&num);
　　　	Push(&num,Pop(&num)/j);
　　　     	break;
　　　	}
　　　		continue;			}
　　　	}
　　　	}
　　　
　　　	printf("结果为 :%d\n",Pop(&num));
　　　	return 0;
　　　}
   6.
   　　　#include<iostream>
　　　#include<string>
　　　using namespace std;
　　　
　　　class Vehicle
　　　{
　　　private: //只有当前类可用
　　　
　　　protected:  //其他package不可用
　　　	string name;
　　　	int wheels;
　　　	int weight;
　　　public:
　　　	Vehicle(int wh, int we, string nm) 
　　　	{
　　　		wheels = wh;
　　　	    weight = we; 
　　　		name = nm;
　　　	}
　　　	void SetWheels(int wh)
　　　	{ 
　　　		wheels = wh;
　　　	}
　　　	void SetWeight(int we) 
　　　	{ 
　　　		weight = we; 
　　　	}
　　　	void SetName(char nm[])
　　　	{
　　　		name = nm;
　　　	}
　　　	int GetWheels() const //将成员成员函数声明为const，不允许修改类的数据成员
　　　	{ 
　　　		return wheels;
　　　	}
　　　	int GetWeight() const 
　　　	{ 
　　　		return weight;
　　　	}
　　　	string GetName() const 
　　　	{ 
　　　		return name; 
　　　	}
　　　	void show() const;
　　　};
　　　void Vehicle::show() const
　　　{
　　　	cout << "汽车类别：" << name << endl;
　　　	cout << "汽车车轮个数：" << wheels << endl;
　　　	cout << "汽车重量：" << weight << endl;
　　　}
　　　class Car :private Vehicle
　　　{
　　　protected:
　　　	int passengerLoad;
　　　public:
　　　	Car(int pl, int wh, int we, string nm) :Vehicle(wh, we, nm), passengerLoad(pl) {}
　　　	void SetPassengerLoad(int pl) { passengerLoad = pl; }
　　　	int GetPassengerLoad() const { return passengerLoad; }
　　　	void show() const;
　　　};
　　　void Car::show() const
　　　{
　　　	cout << "汽车类别：" << name << endl;
　　　	cout << "汽车车轮个数：" << wheels << endl;
　　　	cout << "载人数：" << passengerLoad << endl;
　　　	cout << "汽车重量：" << weight << "kg" << endl;
　　　}
　　　class Truck :private Vehicle
　　　{
　　　protected:
　　　	int passengerLoad;
　　　	int payload;
　　　public:
　　　	Truck(int p, int pd, int wh, int we, string nm) :Vehicle(wh, we, nm), passengerLoad(p), payload(pd) {}
　　　	void SetPassenger(int p) { passengerLoad = p; }
　　　	void SetPayLoad(int pd) { payload = pd; }
　　　	int GetPassenger() const { return passengerLoad; }
　　　	int GetPayLoad() const { return payload; }
　　　	void show() const;
　　　};
　　　void Truck::show()const
　　　{
　　　	cout << "汽车类别：" << name << endl;
　　　	cout << "汽车车轮个数：" << wheels << endl;
　　　	cout << "载人数：" << passengerLoad << endl;
　　　	cout << "载重量：" << payload << "吨" << endl;
　　　	cout << "汽车重量：" << weight << "吨" << endl;
　　　}
　　　int main()
　　　{
　　　	Car car1(4, 4, 1400, "小汽车");
　　　	car1.show();
　　　	Truck truck1(4, 2, 8, 3, "卡车");
　　　	truck1.show();
　　　	return 0;
}
